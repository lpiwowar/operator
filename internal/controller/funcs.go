/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"fmt"
	"math/rand"
	"strconv"
	"sync/atomic"

	apiv1beta1 "github.com/openstack-lightspeed/operator/api/v1beta1"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/config"

	_ "embed"

	common_helper "github.com/openstack-k8s-operators/lib-common/modules/common/helper"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	k8s_errors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	uns "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
	"sigs.k8s.io/controller-runtime/pkg/handler"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
	"sigs.k8s.io/controller-runtime/pkg/source"
)

const (
	// OpenStackLightspeedDefaultProvider - contains default name for the provider created in OLSConfig
	// by openstack-operator.
	OpenStackLightspeedDefaultProvider = "openstack-lightspeed-provider"

	// OpenStackLightspeedOwnerIDLabel - name of a label that contains ID of OpenStackLightspeed instance
	// that manages the OLSConfig.
	OpenStackLightspeedOwnerIDLabel = "openstack.org/lightspeed-owner-id"

	// OpenStackLightspeedVectorDBPath - path inside of the container image where the vector DB are
	// located
	OpenStackLightspeedVectorDBPath = "/rag/vector_db/os_product_docs"

	// OpenStackLightspeedJobName - name of the pod that is used to discover environment variables inside of the RAG
	// container image
	OpenStackLightspeedJobName = "openstack-lightspeed"

	// OLSConfigName - OLS forbids other name for OLSConfig instance than OLSConfigName
	OLSConfigName = "cluster"
)

// WatchInfo holds metadata about a dynamic watch
type WatchInfo struct {
	GVK     schema.GroupVersionKind // The resource type being watched
	Enabled *atomic.Bool            // Whether this watch is currently active
	CRDName string                  // e.g., "openstackcontrolplanes.core.openstack.org"
}

// systemPrompt - system prompt tailored to the needs of OpenStack Lightspeed. It overwrites the default OLS prompt.
//
//go:embed system_prompt.txt
var systemPrompt string

// GetSystemPrompt returns the OpenStackLightspeed system prompt
func GetSystemPrompt() string {
	return systemPrompt
}

// RemoveOLSConfig attempts to remove the OLSConfig custom resource if it exists
// and is managed by the given OpenStackLightspeed instance. It first fetches the OLSConfig,
// checks whether the current OpenStackLightspeed instance is the owner (via label check),
// and if so, removes the finalizer and deletes the OLSConfig resource.
// Returns (true, nil) if the OLSConfig is not found (indicating it has already been deleted).
// Returns (true, nil) if the resource was deleted successfully, or (false, error) if any error occurs.
func RemoveOLSConfig(
	ctx context.Context,
	helper *common_helper.Helper,
	instance *apiv1beta1.OpenStackLightspeed,
) (bool, error) {
	olsConfig, err := GetOLSConfig(ctx, helper)
	if err != nil && !k8s_errors.IsNotFound(err) {
		return false, err
	} else if err != nil && k8s_errors.IsNotFound(err) {
		return true, nil
	}

	_, err = controllerutil.CreateOrPatch(ctx, helper.GetClient(), &olsConfig, func() error {
		ownerLabel := olsConfig.GetLabels()[OpenStackLightspeedOwnerIDLabel]
		isInstanceOwnedOLSConfig := ownerLabel == string(instance.GetObjectMeta().GetUID())

		if ownerLabel == "" || !isInstanceOwnedOLSConfig {
			helper.GetLogger().Info("Skipping OLSConfig deletion as it is not managed by the OpenStackLightspeed instance")
			return nil
		}

		if ok := controllerutil.RemoveFinalizer(&olsConfig, helper.GetFinalizer()); !ok {
			return fmt.Errorf("remove finalizer failed")
		}

		return nil
	})
	if err != nil {
		return false, err
	}

	err = helper.GetClient().Delete(ctx, &olsConfig)
	if err != nil {
		return false, err
	}

	_, err = GetOLSConfig(ctx, helper)
	if err != nil && k8s_errors.IsNotFound(err) {
		return true, nil
	} else if err != nil {
		return false, err
	}

	return false, nil
}

// GetOLSConfig returns OLSConfig if there is one present in the cluster.
func GetOLSConfig(ctx context.Context, helper *common_helper.Helper) (uns.Unstructured, error) {
	OLSConfigGVR := schema.GroupVersionResource{
		Group:    "ols.openshift.io",
		Version:  "v1alpha1",
		Resource: "olsconfigs",
	}

	OLSConfigList := &uns.UnstructuredList{}
	OLSConfigList.SetGroupVersionKind(OLSConfigGVR.GroupVersion().WithKind("OLSConfig"))
	err := helper.GetClient().List(ctx, OLSConfigList)
	if err != nil {
		return uns.Unstructured{}, err
	}

	if len(OLSConfigList.Items) > 0 {
		return OLSConfigList.Items[0], nil
	}

	return uns.Unstructured{}, k8s_errors.NewNotFound(
		schema.GroupResource{Group: "ols.openshifg.io", Resource: "olsconfigs"},
		"OLSConfig")
}

// BuildRAGConfigs builds the RAG configuration array.
// OpenStack RAG is always included first.
// OCP RAG is added if ocpVersion is provided.
func BuildRAGConfigs(instance *apiv1beta1.OpenStackLightspeed, ocpVersion string) []interface{} {
	rags := []interface{}{
		// OpenStack RAG
		map[string]interface{}{
			"image":     instance.Spec.RAGImage,
			"indexPath": OpenStackLightspeedVectorDBPath,
		},
	}

	// Add OCP RAG if enabled
	if ocpVersion != "" {
		rags = append(rags, map[string]interface{}{
			"image":     instance.Spec.RAGImage,
			"indexPath": GetOCPVectorDBPath(ocpVersion),
			"indexID":   GetOCPIndexName(ocpVersion),
		})
	}

	return rags
}

// PatchOLSConfig patches OLSConfig with information from OpenStackLightspeed instance.
func PatchOLSConfig(
	helper *common_helper.Helper,
	instance *apiv1beta1.OpenStackLightspeed,
	olsConfig *uns.Unstructured,
) error {
	// Patch the Providers section
	providersPatch := []interface{}{
		map[string]interface{}{
			"credentialsSecretRef": map[string]interface{}{
				"name": instance.Spec.LLMCredentials,
			},
			"models": []interface{}{
				map[string]interface{}{
					"name": instance.Spec.ModelName,
					"parameters": map[string]interface{}{
						"maxTokensForResponse": float64(instance.Spec.MaxTokensForResponse), // unstructured JSON numbers default to float64
					},
				},
			},
			"name": OpenStackLightspeedDefaultProvider,
			"type": instance.Spec.LLMEndpointType,
			"url":  instance.Spec.LLMEndpoint,
		},
	}

	provider := providersPatch[0].(map[string]interface{})
	if instance.Spec.LLMProjectID != "" {
		if err := uns.SetNestedField(provider, instance.Spec.LLMProjectID, "projectID"); err != nil {
			return err
		}
	}

	if instance.Spec.LLMDeploymentName != "" {
		if err := uns.SetNestedField(provider, instance.Spec.LLMDeploymentName, "deploymentName"); err != nil {
			return err
		}
	}

	if instance.Spec.LLMAPIVersion != "" {
		if err := uns.SetNestedField(provider, instance.Spec.LLMAPIVersion, "apiVersion"); err != nil {
			return err
		}
	}

	if err := uns.SetNestedSlice(olsConfig.Object, providersPatch, "spec", "llm", "providers"); err != nil {
		return err
	}

	// Patch the RAG section
	// Build RAG array with priorities using BuildRAGConfigs
	ragConfigs := BuildRAGConfigs(instance, instance.Status.ActiveOCPRAGVersion)

	if err := uns.SetNestedSlice(olsConfig.Object, ragConfigs, "spec", "ols", "rag"); err != nil {
		return err
	}

	if instance.Spec.TLSCACertBundle != "" {
		tlsCaCertBundle := instance.Spec.TLSCACertBundle
		err := uns.SetNestedField(olsConfig.Object, tlsCaCertBundle, "spec", "ols", "additionalCAConfigMapRef", "name")
		if err != nil {
			return err
		}
	}

	modelName := instance.Spec.ModelName
	err := uns.SetNestedField(olsConfig.Object, modelName, "spec", "ols", "defaultModel")
	if err != nil {
		return err
	}

	err = uns.SetNestedField(olsConfig.Object, OpenStackLightspeedDefaultProvider, "spec", "ols", "defaultProvider")
	if err != nil {
		return err
	}

	// Disable the OCP RAG
	// TODO(lucasagomes): Remove this once we have a "query router" that can
	// handle multiple RAGs nicely
	err = uns.SetNestedField(olsConfig.Object, true, "spec", "ols", "byokRAGOnly")
	if err != nil {
		return err
	}

	// Disable or enable feedback collection
	err = uns.SetNestedField(olsConfig.Object, instance.Spec.FeedbackDisabled, "spec", "ols", "userDataCollection", "feedbackDisabled")
	if err != nil {
		return err
	}

	// Disable or enable transcripts collection
	err = uns.SetNestedField(olsConfig.Object, instance.Spec.TranscriptsDisabled, "spec", "ols", "userDataCollection", "transcriptsDisabled")
	if err != nil {
		return err
	}

	err = uns.SetNestedField(olsConfig.Object, GetSystemPrompt(), "spec", "ols", "querySystemPrompt")
	if err != nil {
		return err
	}

	// Add info which OpenStackLightspeed instance owns the OLSConfig
	labels := olsConfig.GetLabels()
	updatedLabels := map[string]interface{}{
		OpenStackLightspeedOwnerIDLabel: string(instance.GetUID()),
	}
	for k, v := range labels {
		updatedLabels[k] = v
	}

	err = uns.SetNestedField(olsConfig.Object, updatedLabels, "metadata", "labels")
	if err != nil {
		return err
	}

	// Add OpenStack finalizers
	if !controllerutil.AddFinalizer(olsConfig, helper.GetFinalizer()) && instance.Status.Conditions == nil {
		return fmt.Errorf("cannot add finalizer")
	}

	mcpServerConfig := map[string]interface{}{
		"name": "openstack-lightspeed-mcp",
		"streamableHTTP": map[string]interface{}{
			"url": "http://mcp-server-service:8080/openstack/",
		},
	}
	// mcpServerConfig := map[string]interface{}{
	// 	"name": "openstack-lightspeed-mcp",
	// 	"url":  "http://mcp-server-service:8080/openstack/",
	// }
	err = uns.SetNestedSlice(olsConfig.Object, []interface{}{mcpServerConfig}, "spec", "mcpServers")
	if err != nil {
		return err
	}
	// Add featureGates to enable "MCPServe"
	err = uns.SetNestedSlice(olsConfig.Object, []interface{}{"MCPServer"}, "spec", "featureGates")
	if err != nil {
		return err
	}

	return nil
}

// IsOLSConfigReady returns true if OLSConfig's overallStatus is Ready
func IsOLSConfigReady(ctx context.Context, helper *common_helper.Helper) (bool, error) {
	olsConfig, err := GetOLSConfig(ctx, helper)
	if err != nil {
		return false, err
	}

	overallStatus, found, err := uns.NestedString(olsConfig.Object, "status", "overallStatus")
	if err != nil {
		return false, err
	}

	if !found || overallStatus != "Ready" {
		return false, OLSConfigPing(ctx, helper)
	}

	return true, nil
}

// IsOwnedBy returns true if 'object' is owned by 'owner' based on OwnerReference UID.
func IsOwnedBy(object metav1.Object, owner metav1.Object) bool {
	for _, ref := range object.GetOwnerReferences() {
		if ref.UID == owner.GetUID() {
			return true
		}
	}
	return false
}

// GetRawClient returns a raw client that is not restricted to WATCH_NAMESPACE.
// This is useful for operations that need to query resources across all namespaces
// cluster wide.
func GetRawClient(helper *common_helper.Helper) (client.Client, error) {
	cfg, err := config.GetConfig()
	if err != nil {
		return nil, err
	}

	rawClient, err := client.New(cfg, client.Options{Scheme: helper.GetScheme()})
	if err != nil {
		return nil, err
	}

	return rawClient, nil
}

// OLSConfigPing adds a random label to the OLSConfig to trigger a reconciliation
// by the OpenShift Lightspeed operator. This causes the operator to update the Status field.
// Note: This is a workaround for a current limitationâ€”when the OLS operator is installed
// in the openstack-lightspeed namespace, it does not automatically update the OLSConfig
// status as expected.
func OLSConfigPing(ctx context.Context, helper *common_helper.Helper) error {
	const randomLabelKey = "openstack-lightspeed/ping"

	olsConfig, err := GetOLSConfig(ctx, helper)
	if err != nil {
		return err
	}

	labels := olsConfig.GetLabels()
	if labels == nil {
		labels = make(map[string]string)
	}

	labels[randomLabelKey] = strconv.Itoa(rand.Int())
	olsConfig.SetLabels(labels)

	if err := helper.GetClient().Update(ctx, &olsConfig); err != nil {
		return err
	}
	return nil
}

// getCRDName constructs the CRD name from a GVK
// Format: <plural>.<group>
// Uses meta.UnsafeGuessKindToResource for proper pluralization
func getCRDName(gvk schema.GroupVersionKind) string {
	resource, _ := meta.UnsafeGuessKindToResource(gvk)
	if resource.Group == "" {
		return resource.Resource
	}
	return fmt.Sprintf("%s.%s", resource.Resource, resource.Group)
}

// createFilteredHandler creates an event handler that checks if the watch is enabled
// Events are only processed if the enabled flag is true
func (r *OpenStackLightspeedReconciler) createFilteredHandler(
	gvkString string,
	enabled *atomic.Bool,
) handler.TypedEventHandler[*uns.Unstructured, ctrl.Request] {
	return handler.TypedEnqueueRequestsFromMapFunc(func(ctx context.Context, obj *uns.Unstructured) []ctrl.Request {
		// Check if this watch is still enabled
		if !enabled.Load() {
			// Watch is disabled, don't process events
			return nil
		}

		// Watch is enabled, process normally
		return r.NotifyAllOpenStackLightspeeds(ctx, obj)
	})
}

// IsCRDAvailable checks if a CRD exists and is in "Established" state (ready for use)
// Returns (true, nil) if the CRD exists and is established
// Returns (false, nil) if the CRD doesn't exist
// Returns (false, error) for other errors
func (r *OpenStackLightspeedReconciler) IsCRDAvailable(
	ctx context.Context,
	gvk schema.GroupVersionKind,
) (bool, error) {
	crdName := getCRDName(gvk)
	crd := &apiextensionsv1.CustomResourceDefinition{}

	err := r.Get(ctx, client.ObjectKey{Name: crdName}, crd)
	if err != nil {
		if errors.IsNotFound(err) {
			return false, nil
		}
		return false, err
	}

	// Check if CRD is established
	for _, condition := range crd.Status.Conditions {
		if condition.Type == apiextensionsv1.Established && condition.Status == apiextensionsv1.ConditionTrue {
			return true, nil
		}
	}

	return false, nil
}

// RegisterDynamicCRDWatch registers a dynamic watch for a CRD, or re-enables if disabled
// This can be called during reconciliation when you need to start watching a new resource type
func (r *OpenStackLightspeedReconciler) RegisterDynamicCRDWatch(
	ctx context.Context,
	gvk schema.GroupVersionKind,
) error {
	Log := log.FromContext(ctx)
	gvkString := gvk.String()

	// Check if already watching
	if existing, ok := r.WatchedCRDs.Load(gvkString); ok {
		watchInfo := existing.(*WatchInfo)
		if watchInfo.Enabled.Load() {
			Log.Info("Watch already enabled", "gvk", gvkString)
			return nil
		}
		// Re-enable if it was disabled
		watchInfo.Enabled.Store(true)
		Log.Info("Re-enabled watch", "gvk", gvkString)
		return nil
	}

	// Verify the CRD exists before setting up the watch
	crdName := getCRDName(gvk)
	crd := &apiextensionsv1.CustomResourceDefinition{}
	err := r.Get(ctx, client.ObjectKey{Name: crdName}, crd)
	if err != nil {
		return fmt.Errorf("CRD %s not found: %w", crdName, err)
	}

	// Create watch info
	enabled := &atomic.Bool{}
	enabled.Store(true)

	watchInfo := &WatchInfo{
		GVK:     gvk,
		Enabled: enabled,
		CRDName: crdName,
	}

	// Set up the watch with a filtered handler
	u := &uns.Unstructured{}
	u.SetGroupVersionKind(gvk)

	err = r.controller.Watch(
		source.Kind(
			r.Cache,
			u,
			r.createFilteredHandler(gvkString, enabled),
			predicate.TypedResourceVersionChangedPredicate[*uns.Unstructured]{},
		),
	)
	if err != nil {
		return fmt.Errorf("failed to set up watch for %s: %w", gvkString, err)
	}

	// Store the watch info
	r.WatchedCRDs.Store(gvkString, watchInfo)

	Log.Info("Dynamic watch enabled", "gvk", gvkString, "crd", crdName)
	return nil
}

// UnregisterDynamicCRDWatch disables a watch (doesn't remove it, just stops processing events)
// This is idempotent - calling it on a non-existent or already-disabled watch is safe
func (r *OpenStackLightspeedReconciler) UnregisterDynamicCRDWatch(
	gvk schema.GroupVersionKind,
) {
	gvkString := gvk.String()

	if value, ok := r.WatchedCRDs.Load(gvkString); ok {
		watchInfo := value.(*WatchInfo)
		watchInfo.Enabled.Store(false)
	}
}
